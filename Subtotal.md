# 踩坑记录

## PHP-CS-Fixer

* 版本2不允许添加类注解

## 查询条件

page_size的条件必须是“整形、大于等于0”的

page的验证条件必须是“整形、大于等于1”的，不能等于0，因为offset的计算方程是($current_page - 1) * $pageSize，如果传入0，经过计算是个负数，但是mysql查询时，offset是不允许为负的，我们使用模型方法offset()时，这个方法会自动对该参数进行修复：

```php
/**
     * Set the "offset" value of the query.
     *
     * @param int $value
     * @return $this
     */
    public function offset($value)
    {
        $property = $this->unions ? 'unionOffset' : 'offset';

        $this->{$property} = max(0, $value);

        return $this;
    }
```

所以虽然也可以传0进去，但是传0和传1得到的数据是一致的，未免会造成一定程度上的误导，所以我们规定page的最小值为1.

## 验证器

有关于数据库的验证器，如果有批量，最好是不要在验证器进行验证，批量查询验证即可

## 验证数组中是否没有某个值

方法很多，可以用array_diff

## 返回的数据格式

返回的数据字段必须是统一的。

举个例子，当你传入a字段时，该字段才会被查询出来，不传的话，你必须也返回该字段，可以把该字段的值设置为"".

## 埋点

## 可测试

在进行代码编写的时候，就要考虑到，可测试性的问题。比如，我们出bug后首先想到的第一件事就是去查看日志。

比如写一个定时器的时候，应该记录下定时器执行的任务的关键信息。（感觉想的维度可能还有点浅显，先这样，后续补充）

## foreach中return

在循环中，最好不要直接使用return，可读性和可维护性太差。建议在循环外层定义一个是否需要终止程序执行的标识变量，当需要返回的时候，赋值变量，并break，然后在循环外层，判断标识，确定是需要return还是继续执行！

## 批量修改接口的方案设计

1. 创建一个配置文件，里面配置每个接口需要修改的内容，再定义一个中间件统一处理

2. 使用切面，在每个接口上面添加注解，配置需要修改的内容，通过切面进行处理

方案2 优秀一点点吧，更简单。

## !empty()

!empty() 等于 isset($array[$key]) && $array[$key]

## 快速定位bug

首先找到日志，分析基础要素，该bug处于什么环境（测试、预发布、生产），然后找到报错地点，对代码进行分析

## 变量的验证

使用一个变量时，必须先判断它是否存在，特别是使用用户传递的数据时。

## 防注入

不要把用户传的数据直接放到sql里，得做好验证